const Project = require("../models/Project");
const Secret = require("../models/Secret");
const ApiToken = require("../models/ApiToken");
const AuditLog = require("../models/AuditLog");

const getDashboardStats = async (req, res, next) => {
  try {
    const userId = req.user._id;

    // 1. Get all projects accessible by user
    const projects = await Project.find({
      $or: [{ ownerId: userId }, { "members.userId": userId }],
    }).select("_id members");

    const projectIds = projects.map((p) => p._id);

    // 2. Total Secrets Count
    // Count secrets in projects where user is a member
    const totalSecrets = await Secret.countDocuments({
      projectId: { $in: projectIds },
    });

    // 3. Active API Keys
    // Count API Tokens that belong to these projects and are not expired
    const activeApiKeys = await ApiToken.countDocuments({
      projectId: { $in: projectIds },
      expiresAt: { $gt: new Date() },
    });

    // 4. Team Members Count
    // Aggregate unique userIds from members array of all accessible projects
    const allMembers = projects.flatMap((p) =>
      p.members.map((m) => m.userId.toString()),
    );
    const uniqueMembers = new Set(allMembers);
    const teamMembersCount = uniqueMembers.size;

    // 5. Usage History (Audit Logs)
    // Aggregate daily request count for the last 7 days from audit logs
    // We filter by action types related to secret/token access
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    sevenDaysAgo.setHours(0, 0, 0, 0);

    const usageData = await AuditLog.aggregate([
      {
        $match: {
          createdAt: { $gte: sevenDaysAgo },
          // Count relevant actions as "usage"
          action: {
            $in: [
              "secret.read",
              "secret.reveal",
              "secret.create",
              "secret.update",
              "token.create",
            ],
          },
          // Ideally check if resource related to user's projects,
          // but for simplicity, we scope to logs generated by user or in context of user's resources.
          // Since audit logs might not always snapshot projectId, we'll verify userId for now
          // OR if resourceId is in our project lists (requires extensive lookup).
          // For MVP performance, let's count actions performed BY the user or strictly related to them.
          userId: userId, // Only count usage by this user for the dashboard view for now
        },
      },
      {
        $group: {
          _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
          requests: { $sum: 1 },
        },
      },
      {
        $sort: { _id: 1 },
      },
    ]);

    // Fill in missing days
    const formattedUsage = [];
    for (let i = 6; i >= 0; i--) {
      const d = new Date();
      d.setDate(d.getDate() - i);
      const dayStr = d.toISOString().split("T")[0];
      const dayName = d.toLocaleDateString("en-US", { weekday: "short" });

      const found = usageData.find((u) => u._id === dayStr);
      formattedUsage.push({
        name: dayName,
        date: dayStr,
        requests: found ? found.requests : 0,
      });
    }

    return res.json({
      totalSecrets,
      activeApiKeys,
      teamMembers: teamMembersCount,
      usageHistory: formattedUsage,
    });
  } catch (error) {
    return next(error);
  }
};

module.exports = {
  getDashboardStats,
};
